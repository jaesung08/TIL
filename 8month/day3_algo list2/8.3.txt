# 8.3
## 2차원 배열
### 부분집합의 합 문제
* 유한 개의 정수로 이루어진 집합이 있을때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한값이 0이 되는 경우가 있는지 알아내는 문제
* 예를 들어 [-7, -3, -2, 5, 8]이라는 집합이 있을 때, [-3, -2, 5]는 주어진 집합의 부분집합이면서 더한값이 0 이므로 참이 된다.

##### 부분집합의 수
+ 집합의 원소가 n개라면, 공집합을 포함한 부분집합의 수는 2^n개 이다.


#### 비트 연산자
```
b7  b6  b5  b4  b3  b2  b1  b0
□   □   □   □   □   □   □   □
```
* &  : 비트 단위로 AND연산을 한다.
* |  : 비트 단위로 OR연산을 한다.
* <<  : 피연산자의 비트열을 왼쪽으로 이동시킨다.
* >>  : 피연산자의 비트열을 오른쪽으로 이동시킨다.

* << 연산자
    * 1 << ㅜ : 2^n   즉, 원소가 n개 일 경우의 모든 부분집합의 수를 의미.

+ & 연산자
    * i & (i<<j) : i의 j번째 비트가 1인지 아닌지를 검사한다.

* 보다 간결한 부분집합 생성법
```py
arr = [1, 2, 3]

n = len(arr) # n: 원소의 개수

for i in range(1<<n):   # 1<<n : 부분집합의 개수
    for j in range(n):  # 원소의 수만큼 비트를 비교함
        if i & (1<<j):  # i의 j번 비트가 1인 경우
            print(arr[j], end=' ')  # j번 원소 출력
    print()
print()
```

### 검색
* 저장되어 있는 자료중에서 원하는 항목을 찾는 작업
+ 목적하는 탐색 키를 가진 항목을 찾는 것
    * 탐색 키 : 자료를 구별하여 인식할 수 있는 키
* 검색의 종류
    * 순차 검색
    + 이진 검색
    * 해쉬(hash)

#### 순차 검색
* 일렬도 되어있는 자료를 순서대로 검색하는 방법
    * 가장 간단하고 직관적이며, 배열이나 리스트등 순차구조에서 유용하나, 검색 대상의 수가 많으면 수행시간이 증가하여 비효율적임.
* 정렬된 경우
+ 정렬되지 않은 경우

```py
# 순차 검색 알고리즘
def sequentialSearch2(a, n, key)   # 정렬 안되있을 때
    1 <- 0
    while i<n and a[i]!=key:
        i <- i+1
    if i<n :
        return i
    else :
        return -1


def sequentialSearch2(a, n, key)   # 정렬 되있을 때
    1 <- 0
    while i<n and a[i]<key:
        i <- i+1
    if i<n and a[i] == key:
        return i
    else :
        return -1
```


#### 이진 검색
* 자료의 가운데에 있는 항목의 키 값과 비교하여 **다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법**
+ 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.

* 검색과정
     + 자료의 중앙에 있는 원소를 고른다
     * 중앙 원소의 값과 찾고자 하는 원소의 값을 비교하여 작으면 왼쪽의 반에 대해, 크면 오른쪽의 반에 대해서 새로 검색을 수행한다,
     + 찾고자 하는 값을 찾을때 까지 반복

```py

# 이진 검색 알고리즘
def binarySearch(a, N, key)
    start = 0
    end =N -1 
    while start <= end :
        middle = (start + end)//2
        if a[middle] == key : # 검색성공
            return true
        elif a[middle] > key :
            end = middle -1
        else :
            start = middle +1
    return false        # 검색실패
```

+ 재귀 함수로 하는 법도 있음



### 인덱스(index)
* Database에서 유래된 용어로, 테이블에 대한 동작속도를 높여주는 자료구조
+ 인덱스를 저장하기 위해 필요한 디스크 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다
     * 인덱스는 키-필드만 갖고 있고, 테이블의 세부항목은 갖고있지 않기때문이다.
* 배열을 사용한 인덱스

#### 선택 정렬
* 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는방식
+ 정렬과정
    * 주어진 리스트 중에서 최소값을 찾는다.
    * 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
    * 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.
* 시간복잡도 : O(n^2)

```py
# 선택 정렬 알고리즘
# def SelectionSort(a[], n):
#     for i from 0 to n-2
#         a_list[i], ... , a_list [n-1]  # 원소 중 최솟값 a[k]찾음
#         a[i]와 a[k] 교환

def selctionSort(a, N):
    for i in range(N-1):
        minIdx = i
        for j in range(i+1, N):
            if a[minIdx] > a[j]:
                minIdx = j
        a[i], a[minIdx] = a[minIdx], a[i]
```

#### 셀렉션 알고리즘
* 저장되어 있는 자료로부터 K번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 함.
    * 최소값 혹은 최댓값 혹은 중간값을 찾는 알고리즘을 의미한다.

+ 선택과정
    * 정렬 알고리즘을 이용하여 자료 정렬하기
    + 원하는 순서에 있는 원소 가져오기

```py
# k번째로 작은 원소를 찾는 셀렉션 알고리즘
def select(arr, k):
    for i in range(0, k):
        minIndex = i
        for j in range (i+1, len(arr)):
            if arr[minIndex] > arr[j]:
                minIndex = j
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr[k-1]
```
* 선택정렬과 매우유사하나 매개변수가 살짝다르다.
+ 정렬 알고리즘 비교
* 사진 1




