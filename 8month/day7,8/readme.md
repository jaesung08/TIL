# 8.7
## 문자열(string)
#### 아스키코드( ASCII )
    * American Standard Code for Information Interchange 
* 네트워크가 발전하면서 서로간에 정보를 주고 받을 때 정보를 달리 해석하여 원할하지 않다는 문제가 발생함.
* 이를 해결하기위해 표준안을 제작한 것이 아스키 코드
+ 7bit 인코딩으로 128문자를 표현하여 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어짐

* 확장 아스키는 문자이외에 특수문자, 기호, 도형, 악센트 등 128개를 추가한 부호이다.
     + 7bit가 아닌 8bit를 모두 사용하여 추가적인 문자를 표현

#### 유니코드
* 인터넷이 전세계로 발전하고 국가간에 정보를 주고 받을 때 문제가 발생했다.
+ 자국의 코드체계를 타국가가 가지고 있지않으면 정보를 제대로 해석하지 못한 다는 것.
* 다국어 처리를 위해 또다시 마련한 표준이 바로 유니코드
*  Universal Character set2 와 Character set4로 분류 된다.
     * 유니코드를 저장하는 변수의 크기를 정의한 것이나, 바이트 순서에 대해 표준화되지 않았음
    + 하여 UCS2 와 UCS4를 인식하고 구분하여 사용해야 하는 문제가 발생했음.
     * 그래서 유니코드의 적당한 외부 인코딩이 필요함.


##### 유니코드 인코딩 (UTF : Unicode Transformation Format)
* UTF-8 (in web)
     * Min : 8bit , Max : 32bit(1Byte * 4)
* UTF-1 (in windows, java)
     * Min : 16bit , Max : 32bit(2Byte * 2)
* UTF-8 (in unix)
     * Min : 32bit , Max : 32bit(4Byte * 1)

###### pyhton 인코딩 
* 2x 버전 -ASCII => #-*-coding : utf-8 -*- (첫줄에 명시)
+ 3x 버전 - 유니코드 ==> UTF-8 생략 가능
* 다른 인코딩 방식 처리 시 첫줄에 원하는 인코딩 방식 지정


### 문자열의 분류
...

### 패턴 매칭에 사용되는 알고리즘들
+ 고지식한 알고리즘
* 카프-라빈 알고리즘
+ KMP 알고리즘
* 보이어 무어 알고리즘

#### 고지식한 알고리즘
* 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작
```py
'''
만약 
T T T T A A C C A ,,, 라는 본문 문자열이 있을 때,
T T A T T T C T A ,,, 라는 패턴 문자열과 비교할 때
각 자리 별 비교 후 일치 하지 않을 경우 한칸 씩 이동하여 비교하는 알고리즘.
본문 문자열을 처음부터 끝까지 차례대로 한칸씩 순회하는 방식.
'''
p = "is" # 찾을패턴
t = "This is a book~!" # 전체 문자열
m = len(p) # 찾을 패턴의 길이
n = len(t) # 전체 문자열의 길이

def BruteForce(p, t):
	i = 0 # t의 인덱스
	j = 0 # p의 인덱스
	while j < m and i < n :
		if t[i] != p[j]
		i = i - j
		j = -1
	i = i + 1
	j = j + 1
	if j ==m : return i - m  # 검색 성공
	else: return -1  # 검색 실패
```
+ 시간복잡도는 최악의 경우 O(nm)이 됨.
+ swea 1213


#### KMP 알고리즘
* 불일치가 발생한 문자열 스트링 앞 부분에 어떤 문자가 있는지, 미리 알고 있으므로, 앞부분에 대해 다시 비교하지않고 매칭 수행
```py
# 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화 함
# next[M] : 불일치가 발생했을 경우 이동할 다음 위치

# KMP 알고리즘
def kmp(t,p):
    N = len(t)
    M = len(p)
    lps = [0] * (M+1)

    j = 0  # 일치한 개수 == 비교할 패턴 위치
    lps[0] = -1
    for i in range(1, M):
        lps[i] = j      # p[i]이전에 일치한 개수
        if p[i] == p[j]:
            j += 1
        else:
            j = 0
    lps[M] = j
    print(lps)
```
+ 시간 복잡도 O(n+m)

#### 보이어-무어 알고리즘
* 역순으로 비교
* 대부분 SW에서 채택하는 알고리즘
+ 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동거리는 무려 패턴의 길이 만큼이 된다.

##### 문자열 매칭 알고리즘 비교
* 문자열 패턴의 길이 : m // 총 문자열의 길이 : n 일때
* 고지식한 패턴 검색 알고리즘 : 수행시간 O(mn)
* 카프-라빈 알고리즘 : 수행시간 Θ(n)  # Θ는 항상 이만큼은 걸린다는 뜻.
* KMP 알고리즘 : 수행시간 Θ(n)

* 보이어-무어 알고리즘 : 수행시간 최악의 경우 : Θ(mn) 일반적으론 Θ(n)보다 작음.


#### 참고 
##### 문자열 암호화
* 시저암호 : 키값을 랜덤하게 움직여 바꾼 암호
* 카이사르 암호 : 키값을 1만큼 평행하게 미룬 코드
* bit열의 암호화 : 배타적 논리합 (exclusive-or // xor) 연산을 사용 // 같은 값이 몇번 사용됐는가를 나타냄으로서 압축
