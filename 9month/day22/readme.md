# 0922 문제풀이
## swea 1486 장훈이의 높은 선반
```
장훈이는 서점을 운영하고 있다.

서점에는 높이가 B인 선반이 하나 있는데 장훈이는 키가 매우 크기 때문에, 선반 위의 물건을 자유롭게 사용할 수 있다.

어느 날 장훈이는 자리를 비웠고, 이 서점에 있는 N명의 점원들이 장훈이가 선반 위에 올려놓은 물건을 사용해야 하는 일이 생겼다.

각 점원의 키는 Hi로 나타나는데, 점원들은 탑을 쌓아서 선반 위의 물건을 사용하기로 하였다.

점원들이 쌓는 탑은 점원 1명 이상으로 이루어져 있다.

탑의 높이는 점원이 1명일 경우 그 점원의 키와 같고, 2명 이상일 경우 탑을 만든 모든 점원의 키의 합과 같다.

탑의 높이가 B 이상인 경우 선반 위의 물건을 사용할 수 있는데 탑의 높이가 높을수록 더 위험하므로 높이가 B 이상인 탑 중에서 높이가 가장 낮은 탑을 알아내려고 한다.


[입력]

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 두 정수 N, B(1 ≤ N ≤ 20, 1 ≤ B ≤ S)가 공백으로 구분되어 주어진다.

S는 두 번째 줄에서 주어지는 점원들 키의 합이다.

두 번째 줄에는 N개의 정수가 공백으로 구분되어 주어지며, 각 정수는 각 점원의 키 Hi (1 ≤ Hi ≤ 10,000)을 나타낸다.


[출력]

각 테스트 케이스마다 첫 번째 줄에는 ‘#t’(t는 테스트 케이스 번호를 의미하며 1부터 시작한다)를 출력하고, 만들 수 있는 높이가 B 이상인 탑 중에서 탑의 높이와 B의 차이가 가장 작은 것을 출력한다.


[예제 풀이]

테스트 케이스의 경우 키가 3, 3, 5, 6인 점원이 탑을 만들면 높이가 17(3 + 3 + 5 + 6)이 된다.

높이가 16인 탑은 만들 수 없으므로 높이가 17인 탑이 문제에서 구하려는 탑의 높이이다. 따라서 17 – 16 = 1이 답이 된다.
```
```
입력
1
5 16
1 3 3 5 6

출력
#1 1
```
1. 문제해석
- 문제에서 원하는 목표
- => 명확하게 문제를 파악해야함

> **예시**
- 서점
  - 높이가 B인 선반
  - 선반
    - 키가 큰 장훈이는 물건을 자유롭게 이용할 수 있따.
  - 점원 (키 Hj)
    - 선반의 물건을 사용하기 위해 탑을 쌓는다.
    - 탑을 쌓는 방법
      - 1명: 점원의 키 == 탑의 높이
      - 2명 이상 : 점원 키의 합 == 탑의 높이
      + => 선반보다 높거나 같을경우 물건을 쓸 수 있다.
  - 높이가 B이상인 탑 중에서, 높이가 가장 낮은 탑을 구해라.

> 문제해석 완료
- 운영
2. 무슨 알고리즘을 쓸까?
+ 시뮬레이션을 해보니, 미리 무언가를 구할 수가 없다!
  + => 모든 경우의 수를 보아야한다.
  1. 완전탐색문제 이다 라고 생각하고 접근 

- 먼저 떠오르는 알고리즘이 있다면, 시간을 먼저 계산
+ 파이썬은 대략 1초에 2천만번

- => 이 문제는 완전탐색으로 풀면 O(20!)
- N은 최대 20이기 때문에 20으로 계산하면 
  - 시간초과가 난다!

+ backtracking
  + => 획기적으로 완전탐색에서 경우의 수를 줄여보자

```py
T = int(input())

def recur(level, acc_height):
    global ans

    # 가지치기
    # 현재까지 탑이 선반 높이를 넘어간다면
    # 앞으로는 더 볼 필요가 없다.
    if acc_height >= B:
        ans = min(ans, acc_height)
        return

    # 기저 조건
    if level == N:
        return

    # 해당 점원을 탑에 쓸 경우
    recur(level + 1, acc_height + arr[level])
    # 안쓸 경우
    recur(level + 1, acc_height)

    # 기저 조건
    # 들어가기전(가지치기)
    # 다음 재귀함수 호출
    # 돌아왔을 때
    # 이번에는 순서를 바꿔서 가지치기 먼저

for tc in range(1, T+1):
    N, B =map(int, input().split())
    arr = list(map(int, input().split()))
    ans = float('inf') # 무한대로 큰 숫자
    recur(0, 0)
    print(f'#{tc} {ans - B}')

```


1. 완전 탐색 접근
2. 가지치기(백트래킹 )
   - 트리 구조로 생각할 순 없는가?
   - 이전 데이터를 봐야하는 지 유무에 따라


## swea 1952 DFS

## swea 2819 DFS
```
4×4 크기의 격자판이 있다. 격자판의 각 격자칸에는 0부터 9 사이의 숫자가 적혀 있다.

격자판의 임의의 위치에서 시작해서, 동서남북 네 방향으로 인접한 격자로 총 여섯 번 이동하면서, 각 칸에 적혀있는 숫자를 차례대로 이어 붙이면 7자리의 수가 된다.

이동을 할 때에는 한 번 거쳤던 격자칸을 다시 거쳐도 되며, 0으로 시작하는 0102001과 같은 수를 만들 수도 있다.

단, 격자판을 벗어나는 이동은 가능하지 않다고 가정한다.

격자판이 주어졌을 때, 만들 수 있는 서로 다른 일곱 자리 수들의 개수를 구하는 프로그램을 작성하시오.


[입력]

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스마다 4개의 줄에 걸쳐서, 각 줄마다 4개의 정수로 격자판의 정보가 주어진다.


[출력]

각 테스트 케이스마다 ‘#x ’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고, 격자판을 이동하며 만들 수 있는 서로 다른 일곱 자리 수들의 개수를 출력한다.
```
```
입력
1
1 1 1 1
1 1 1 2
1 1 2 1
1 1 1 1

출력
#1 23
```
- 격자판
- => 이차원 배열
- => 각 격자칸 : 0 ~ 9 숫자
<br><br>
- 현재지점 + 6번 이동하면서 숫자를 붙임
- => 이동 4방향(방향배열)
<br><br>
- 격자칸을 다시 가도된다
- => visited 안써도 된다
<br><br>
- 0 시작: 0102001
- => 숫자가 0으로 시작할 수 있네?
- => 문자열로 해결하면 편하겠다
<br><br>
- 요구하는 조건:
- => 서로 다른 일곱 자리 수들의 개수
- 가지치기 불가능
- 무조건 일곱자리 숫자를 다 붙여봐야함
<br><br>
- 시간 계산
- 4*4 *7자리
- 완전 탐색을 돌려도 가능할 것이다.
<br><br>
- 서로 다른 일곱 자리 수들의 개수
- => 중복을 제거할 방법??
- => set자료구조!
<br><br>
1. 재귀돌리면서 숫자를 붙인다
2. 숫자가 7자리가 되면
3. set에 저장한다.

```py
T = int(input())
move = [(0, 1), (0, -1), (1, 0), (-1, 0)]
# 특정위치를 기점으로 상하좌우 문자를 붙여아하므로
# 파라미터로 좌표값도 받아야한다.
def dfs(y, x, number):
    if len(number) == 7:
        result.add(number)
        return

    for dy, dx in move:
        ny = y+ dy
        nx = x+ dx

        ## 갈 수 없는 위치면 continue
        if ny <0 or ny >= 4 or nx <0 or nx >= 4:
            continue

        # 갈수 있따면 다음ㅊ위치로 이동
        dfs(ny, nx, number + maps[ny][nx])


for tc in range(1, T+1):
    # 서로 다른 수를 합친다 => 문자열이 더 좋다
    maps = [input().split() for _ in range(4)]

    # 7자리 수를 중복 제거하여 저장
    result = set()
    # 시작지점 돌리기
    for i in range(4):
        for j in range(4):
            dfs(i, j, maps[i][j])
    
    print(f'#{tc} {len(result)}')
```


## swea 1238 BFS
```
비상연락망과 연락을 시작하는 당번에 대한 정보가 주어질 때, 가장 나중에 연락을 받게 되는 사람 중 번호가 가장 큰 사람을 구하는 함수를 작성하시오.
 
[예시]

아래는 비상연락망을 나타낸 그림이다.
 


 
각 원은 개개인을 의미하며, 원 안의 숫자는 그사람의 번호를 나타내고 빨간원은 연락을 시작하는 당번을 의미한다.

화살표는 연락이 가능한 방향을 의미한다.

위의 예시에서는 7번과 1번은 서로 연락이 가능하다,

하지만 2번과 7번의 경우 2번은 7번에게 연락할 수 있지만 7번은 2번에게 연락할 수 없다.
 
비상연락망이 가동되면 아래 그림과 같이 연락을 시작하는 당번인 2번은 연락 가능한 7번과 15번에 동시에 연락을 취한다 (다자 간 통화를 사용한다고 가정).
 

 
그 다음 아래와 같이 7번은 1번에게, 15번은 4번에게 연락을 취한다 (이 과정은 동시에 일어난다고 가정한다).
 


그 다음 아래와 같이 1번은 8번과 17번에게 동시에 연락하며, 이와 동시에 4번은 10번에게 연락한다.

7번과 2번의 경우는 이미 연락을 받은 상태이기 때문에 다시 연락하지 않는다.
 


위의 모습이 연락이 끝난 마지막 모습이 되며, 마지막에 동시에 연락 받은 사람은 8번, 10번, 17번의 세 명이다.

이 중에서 가장 숫자가 큰 사람은 17번이므로 17을 반환하면 된다.
 
※ 3, 6, 11, 22번은 시간이 지나도 연락을 받지 못한다.
 
[제약 사항]

연락 인원은 최대 100명이며, 부여될 수 있는 번호는 1이상, 100이하이다.

단, 예시에서 5번이 존재하지 않듯이 중간 중간에 비어있는 번호가 있을 수 있다.

한 명의 사람이 다수의 사람에게 연락이 가능한 경우 항상 다자 간 통화를 통해 동시에 전달한다.

연락이 퍼지는 속도는 항상 일정하다 (전화를 받은 사람이 다음사람에게 전화를 거는 속도는 동일).

비상연락망 정보는 사전에 공유되며 한 번 연락을 받은 사람에게 다시 연락을 하는 일은 없다.

예시에서의 3, 6, 11, 22번과 같이 연락을 받을 수 없는 사람도 존재할 수 있다.
 
[입력]

10개의 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 입력 받는 데이터의 길이와 시작점이 주어진다.

그 다음 줄에 입력받는 데이터는 {from, to, from, to, …} 의 순서로 해석되며 예시의 경우는 {2, 7, 11, 6, 6, 2, 2, 15, 15, 4, 4, 2, 4, 10, 7, 1, 1, 7, 1, 8, 1, 17, 3, 22}와 같다.

그런데 순서에는 상관이 없으므로 다음과 같이 주어진 인풋도 동일한 비상연락망을 나타낸다 (같은 비상연락망을 표현하는 다양한 인풋이 존재 가능하다).

{1, 17, 3, 22, 1, 8, 1, 7, 7, 1, 2, 7, 2, 15, 15, 4, 6, 2, 11, 6, 4, 10, 4, 2}

다음과 같이 동일한 {from, to}쌍이 여러 번 반복되는 경우도 있으며, 한 번 기록된 경우와 여러 번 기록된 경우의 차이는 없다.

{1, 17, 1, 17, 1, 17, 3, 22, 1, 8, 1, 7, 7, 1, 2, 7, 2, 15, 15, 4, 6, 2, 11, 6, 4, 10, 11, 6, 4, 2}
 
[출력]

#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스에 대한 답을 출력한다.
```

- 연락하는 방법
- 가장 나중에 연락받는 사람중 가장 큰 사람
- 시점을 구하는 방법
- 동시에 연락받은 사람 => BFS써라
- 한번 전화한 사람은 가지않는다 = > visited 써라
- 중간중간 비어있는 번호가 있을 수 있다 => 인접리스트 써라
  

```py
def bfs(s):
    q = [s]
    visited = [0] * 101
    # 시작점은 방문처리
    visited[s] = 1

    # 최대 숫자와 최대 깊이를 저장할 변수
    max_number = s
    max_depth = 1

    while q:
        now = q.pop(0)

        # 갈 수 있는 지점 다 봐라
        for to in graph[now]:
            if visited[to]:
                continue

            # 기존 방문보다 한 번 더 갔다.
            visited[to] = visited[now] + 1

            # 한 단계 깊은 곳으로 가거나
            # 깊이는 같은데 숫자가 더 ㅋ다면
            # max값 초기화
            if max_depth < visited[to] or (max_depth == visited[to] and max_number < to):
                max_depth = visited[to]
                max_number = to

            q.append(to)
    return max_number

T = 10
for tc in range(1, T+1):
    n, start = map(int, input().split())
    input_graph = list(map(int, input().split()))

    graph = [[] for _ in range(101)]
    for i in range(0, n, 2):
        f = input_graph[i]
        t = input_graph[i + 1]
        graph[f].append(t)
    r = bfs(start)
    print(f'#{tc} {r}')
```
```
0. IDE를 적극적으로 활용해라
- input.in 써서, 복사하지 말고 사용
- 디버깅 툴 -> 적극적으로 써라
   => print로 다 디버깅해야함
   => 적재적소에 print를 사용할 줄 알아야함
   => 디버깅 툴을 활용해서 연습

1. 문제를 봤을 때, 원하는 알고리즘을 선택
1.1 일단 완전탐색으로 생각해봐라
 => N 값을 확인해서, 시간복잡도 확인

1.2 백트래킹 하는 방법 생각
1.3 조금 더 어려운 알고리즘
  - 그리디 ( 규칙찾기)
  - DP ( 두번 계산하지 않기)
  - Union-Find
  ```