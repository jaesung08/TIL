- 생성자 
메서드명이 클래스명과 동일하고 리턴 자료형을 정의하지 않는 메서드를 생성자라고 한다. 생성자 규칙은 다음과 같다.
	클래스명과 메서드명이 같다.
	리턴 타입을 정의하지 않는다(void도 사용하지 않는다.).
생성자는 객체가 생성될 때 호출된다. 즉, 생성자는 다음과 같이 new 키워드가 사용될 때 호출된다.

- 인터페이스
자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있다는 장점을 가지게 될 것이다.
하지만 클래스를 이용하여 다중 상속을 할 경우 메소드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속은 지원하지 않는다.
하지만 다중 상속의 이점을 버릴 수는 없기에 자바에서는 인터페이스라는 것을 통해 다중 상속을 지원하고 있다.
인터페이스(interface)란 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스를 의미한다.

자바에서 추상 클래스는 추상 메소드뿐만 아니라 생성자, 필드, 일반 메소드도 포함할 수 있습니다.
하지만 인터페이스(interface)는 오로지 추상 메소드와 상수만을 포함할 수 있습니다.  
=> 추상 메서드의 집합을 정의하는데 사용되는 추상 형식

- 상속
클래스가 다른 클래스의 특성과 동작을 이어받는 것

- 추상클래스
하나 이상의 추상 메서드를 포함하는 클래스. 객체(인스턴스)를 직접 생성할 수 없음.
추상 메소드(abstract method)란 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드를 의미
abstract class 클래스이름 {
    ...
    abstract 반환타입 메소드이름();
    ...
}

- solid 원칙
SRP(Single Responsibility Principle): 단일 책임 원칙
=> "한 클래스는 하나의 책임만 가져야 한다."
OCP(Open Closed Priciple): 개방 폐쇄 원칙
=> "소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다."
LSP(Listov Substitution Priciple): 리스코프 치환 원칙
=> "서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다."
ISP(Interface Segregation Principle): 인터페이스 분리 원칙
=> "클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다."
DIP(Dependency Inversion Principle): 의존 역전 원칙
=> "추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다."

- static
프로그램이 시작되는 시점에 클래스 로더가 클래스를 해석하여 메소드 영역 혹은 힙 영역에 클래스 메타 데이터 및 정적 변수 등을 적재
지양 해야 하는 이유


- 접근 제한자 
클래스, 메서드, 변수에 대한 접근 권한을 제어하는 키워드. 
접근제한자	적용대상			접근가능대상

public		클래스, 필드, 생성자, 메소드	모든대상
protected	필드, 생성자, 메소드 	같은 패키지 또는 자식 클래스
default		클래스, 필드, 생성자, 메소드	같은 패키지에 소속된 클래
private		필드, 생성자, 메소드	클래스 내부

- 싱글 톤 디자인 패턴
싱글톤 패턴을 사용하는 이유는 정보를 보관하고 공유하고자 하는 클래스(예시의 '회사'클래스)가 한 번의 메모리만 할당하고 그 할당한 메모리에 대해 객체로 관리하기 위함
이렇게 되면 여러 클래스에서 각자 '회사'클래스의 생성자를 호출하더라도 처음 한 번 생성된 인스턴스를 반환해주기 때문에 정보 공유 차원에서의 변수 관리 즉 동기화에 용이

=> 생성(Creational) 패턴 중 하나로써 객체를 오직 하나만 생성하여 생성된 객체를 프로그램 어디에서나 접근하여 사용할 수 있도록 하는 패턴이다.
​==> 간단히 말해서 애플리케이션 전체에서 단 하나의 객체만 생성하고 필요할 때마다 이 객체에 접근하여 사용하겠다는 의미이다

```java
public class CompanyInfo 
{
    private static CompanyInfo innstance;
 
    private String companyName;
    private String companyAddr;
    
    
    private CompanyInfo()
    {
    }
    
    public static CompanyInfo getInstance()
    {
        if (innstance == null)
        {
            synchronized(CompanyInfo.class)
            {
                innstance = new CompanyInfo();
            }
        }
        
        return innstance;
    }
    
    
    // getter, setter 
    public String getCompanyName() {
        return companyName;
    }
 
    public void setCompanyName(String companyName) {
        this.companyName = companyName;
    }
 
    public String getCompanyAddr() {
        return companyAddr;
    }
 
    public void setCompanyAddr(String companyAddr) {
        this.companyAddr = companyAddr;
    }    
}
```


- 게터 세터
Getter, Setter = 객체의 필드 값을 얻거나 설정하는 메서드
private 으로 할당된 클래스의 값을 얻거나 설정하기 위해 사용 

- 메모리 할당
프로그램이 실행될 때 변수, 객체 및 데이터 구조를 저장하기 위한 메모리를 할당하는 프로세스



- DI ( Dependency Injection )
의존성 주입. 객체가 직접 의존하는 객체를 생성하는 것이 아니라 외부에서 주입받는 패턴.

- IOC ( Inversion of Control )
제어의 역전. 프레임워크 또는 컨테이너가 애플리케이션의 흐름을 제어하는 것.


- 이퀄스
equals : 두 객체의 동등성을 비교하는 메서드
- 해시코드
hashCode : 객체의 해시 코드를 반환하는 메서드. 해시 기반의 자료구조에서 사용


- object 기법
Object 클래스: 자바의 모든 클래스의 최상위 클래스. 다른 클래스에서 상속받는 기본적인 메서드들을 제공

- 오버라이딩 오버로딩 차이
오버로딩은 이름은 같지만 시그니처(파라미터 수, 타입) 데는 다른 메소드를 중복으로 선언하는 것을 의미
	1. 메소드 이름이 같아야함.
	2. 리턴형은 같아도 달라도 가능
	3. 파라미터 개수가 달라야 한다.
	4. 파라미터 개수가 같을 시, 데이터 타입이 달라야 한다.
	* 리턴 타입은 시그니처에 포함되지 않기 때문에 주의. 컴파일 에러 발생.
	=> 같은 메소드라도 매개변수만 다르면 얼마든지 정의하고 사용

오버라이딩은 부모 클래스의 메소드의 동작 방법을 변경(재정의)하여 우선적으로 사용하는 것
	1. 오버라이드 하고자 하는 메소드가 상위 클래스에 존재해야 한다.
	2. 메소드 이름이 같아야 한다.
	3. 메소드 파라미터 개수, 파라미터의 자료형이 같아야 한다.
	4. 메소드 리턴형이 같아야 한다.
	5. 상위 메소드와 동일하거나 내용이 추가되어야 한다.
	=>상속 관계에 있는 클래스 간에 같은 이름의 메소드를 정의하는 기술이다.
	    만약 자식클래스가 부모클래스에서 선언된 것과 같은 메소드를 가질 때, 메소드 오버라이딩

오버로딩(overloading)은 한 클래스 내에, 여러 개의 같은 이름의 메소드를 정의하는 것을 말한다. 이렇게 메소드의 이름을 동일하게 만들어 프로그램의 가독성을 증가시킬 수 있다는 장점이 있다.
오버라이딩은(overriding)은 부모로부터 받은 메소드의 로직(내부)을 입맛에 맞게 변경하는 것이다. 객체지향 언어의 특징인 다형성 중 하나이다.

- 제너릭
데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법
제네릭(Generic)은 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미한다. 
한마디로 특정(Specific) 타입을 미리 지정해주는 것이 아닌 필요에 의해 지정할 수 있도록 하는 일반(Generic) 타입
정적 메소드로 선언할 때 필요로 하다

------------------------------------------------
Generic(제네릭)의 장점
1. 제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.
2. 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 즉, 관리하기가 편하다.
3. 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.
객체<타입> 객체명 = new 객체<타입>();

타입	설명
<T>	Type
<E>	Element
<K>	Key
<V>	Value
<N>	Number
타입인자를 두가지로 받는 HashMap 처럼 <T, K> 로 지정도 가능하다.
class 클래스명<T> 처럼 클래스명의 타입 파라미터를 지정도 가능하다.


- 컴퍼러블, 컴패럴레이터
Comparable: 인터페이스. 정렬 가능한 클래스들이 구현하여 객체 간의 순서를 정의.
Comparator: 비교자 인터페이스. 별도로 구현하여 정렬 방법을 지정할 수 있음.
Comparable 혹은 Comparator을 사용하고자 한다면 인터페이스 내에 선언된 메소드를 '반드시 구현'해야한다
------------------------------------------------


- 람다식
람다식 (Lambda Expression): 익명 함수를 정의하는데 사용되는 표현식. 
함수를 하나의 식(expression)으로 표현한 것으로 주로 함수형 인터페이스를 구현할 때 활용.
익명함수들은 공통으로 일급객체(First Class citizen)라는 특징
=> 람다식으로 메서드를 변수처럼 다루는 것이 가능

반환 값이 있는 메서드의 경우, return문을 생략하고 식으로 대신합니다.
그리고 이 식의 끝에 세미콜론 ' ; '을 붙이지 않습니다.
람다식에 선언된 매개변수의 타입 또한 생략이 가능합니다.
ex) 
int max ( int a, int b ) {
return a > b ? a : b ; 
}

=>

( int a, int b ) -> { return a > b ? a : b ; }

=> 

( int a, int b ) -> a > b ? a : b ;

=>

( a, b ) -> a> b ? a : b ;