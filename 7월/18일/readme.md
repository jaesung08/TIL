# 7.18
## Data Types
* 값의 종류와 그 값에 적용 가능한 **연산과 동작을 결정** 하는 속성
    * Numeric Type = 정수(int), 실수(float), complex(복소수)
    * set type = set, dict
    * sequence type = list, tuple, range
    * text sequence type = str(문자열)
    * mapping type = dict
    * 기타 = none, boolean, functions
    * **리스트, 튜플, 딕션너리 의 차이점을 잘알아야함**

* 데이터 타입이 필요한 이유
    * 값들을 구분하고 어떻게 다뤄야 하는지 알 수 있음.
    * 각 데이터 값에 적합한 도구를 가짐
    * 타입을 명시적으로 지정하여, 코드를 읽는 사람이 변수의 의도를 더 쉽게 이해하고, 잘못된 데이터 타입의 오류를 미리 예방

## Numeric Type
### int = 정수 자료형
    * 2진수(binary) = 0b    [print(0b10) #2]
    * 8진수(octal) = 0o     [print(0x30) #24]
    * 16진수(hexadeciaml) = 0x     [print(0x10) #16]

    * print(bin(12))	= 0b1100
    * print(oct(12))	= 0o14
    * print(hex(12))	= 0xc

### float = 실수 자료형(실수에 대한 근삿값)
     * 유한 정밀도
         * 0.66666666666666666 = 2/3에 대한 근삿값
         * 1.66666666666666667 = 5/3에 대한 근삿값
         * 컴퓨터는 2진수를 쓰기 때문에 0.1을 2진수로 표현하면 무한대로 반복
         * => 무한대숫자를 표현 할수 없어 10진법의 근사값을 표시
         * 이런 증상을 floating point rounding error 라고 함
 * 실수 연산 시 해결책
    * 1. 임의의 작은 수 활용
    * 2. math 모듈 활용
 * ![실수 연산시 해결책](<사진1 실수 연산의 해결책.png>)
    * 지수 표현 방식
         * 314 * 0.01 = 314e - 2 = 314**(-2)
         * e = 10^
  
## Sequence Type = 여러개의 값들을 **순서대로 나열** 하여 저장하는 자료형
    * ( str, list, tuple, range )
    * 순서(sequence) = 값들이 순서대로 저장 (정렬XXX)
    * 인덱싱(indexing) = 각 값에 고유인덱스(번호)를 가지고 있어, 인덱스를 사용하여 특정 위치 값을 선택하거나 수정할 수 있음
    * 슬라이싱(slicing) = 인덱스 범위를 조절해 부분적인 값을 추출 가능
    * 길이(legnth) =  len()함수를 사용하여 저장된 값의 갯수(길이)를 구할 수 있음
    * 반복(lteration) = 반복문을 사용하여 저장된 값들을 반복적으로 처리 가능
    * 5가지 모두 사용가능하고 가변,불변에 따라 나눌수 있음

### str = 문자열( **불변** 시퀸스자료형 )
 * 문자열은 여러 문자의 조합
 * 작은 따옴표(') 또는 큰따옴표(") 으로 감싸서 표현 
     * 중첩따옴표 => 작은 따옴표 안에 큰따옴표로 표현, 큰따옴표 안에 작은 따옴포로 표현
     *   " 가나다라마바사'아자차카'타파하"
 * 역슬래시를 사용하여 특수한 기능 사용
     * \\n = 줄바꿈
     * \\t = 문자 사이 탭 삽입
     * \\\ = 백슬래시
     * \\' = 작은 따옴표
     * \\" = 큰따옴표
         * print( '철수야 \\' 안녕 \\' ' ) = 철수야 '안녕'

 * string Interpolation = 문자열 내 변수나 표현식을 삽입하는 방법
     * f-string = f 또는 F 접두어를 붙이고 표현식을 {expression}으로 작성하여 문자열에 파이썬 표현식의 값을 삽입함.
     * print(f'Debugging {bugs} {counts} {area}')  => {} 자리에 각 변수에 입력된 값이 출력
     * (이전에는 .format 이라는 함수를 사용 하였으나 최근에는 f-string 사용)
     * (더 이전에는 %s, %d, %f 등을 사용했음 )
     * 인덱싱 = 그 자리의 요소 찾아오기 //  슬라이싱 = 그 사이의 자리 요소 찾아오기 // 길이 = 요소의 갯수
     * ![문자열 시퀸스 특징](<사진2 문자열 시퀀스 특징.png>)

 * 인덱스 = 시퀀스 내의 값들에 대한 고유 번호, 각 값의 위치를 식별
     * ![사진3](<사진3 인덱스.png>)

 * 슬라이싱 = 시퀸스의 일부범위를 추출하여 새로운 시퀸스를 생성
    * ![사진4](<사진4 슬라이싱.png>)
    * 슬라이싱 범위의 마지막은 예외
    * [ :3] 이라면 처음부터 3까지 // 처음이라는 값은 작성X
    * [3: ] 이라면 3부터 마지막 까지 // 마지막 또한 마찬가지
    * 마지막에 -1 은 시작지점이 0이라는 인덱스의 특성을 고려한것이다 !
    * ![사진5](<사진5 슬라이싱.png>)
    * [0:5:2] 0부터5까지 (step)2칸씩 추출
    * [ : : -1] step을 음수로 추출할 시 거꾸로 읽혀 hello가 olleh로 추출 => **문자열 뒤집기**
```
    * greeting[start:end:step]
    * step>0 이면 start가 0이므로 end-1
    * step<0 이면 start가 -1이므로 end+1
```
#### => 문자열은 불변입니다. 잊지마세요. 필요하면 새로운 문자열을 만들기.


### list = **가변** 시퀸스 자료형
* 리스트는 0개 이상의 객체 포함하여 데이터 목록 저장 // 빈 리스트가 가능
* 대괄호( [ ] )로 표시
* 어떠한 자료형도 저장할 수 있음
    * [ 1, 2, 3 'pyhthon' , ['hello', 'world' , '!!!']] => 5개의 자료

* 중첩된 리스트의 접근
    * ![사진6](<사진6 중첩리스트 접근.png>)
    * [4][-1] 4번째 인덱스의 -1 즉 문자열의 마지막 값 '!!!' 출력
    * [-1][1][0] 3단계를 걸쳐 w 출력

* 가변형 !! 인덱스를 호출하여 다른 값을 입력가능 
    * ![사진7](<사진7 리스트 가변.png>)

### Tuple = 불변 시퀸스 자료형
* 0개 이상의 객체 포함 // 빈 튜플 가능
* 소괄호로( () )로 표시
* 어떤 자료형도 저장 가능
* 하나의 자료형만 있어도 (1, ) 으로 " , " 를 사용해야함

* 리스트와 유사하나 불변 데이터 자료형
    * => 개발자가 쓰기보다는 **파이썬의 내부 동작**에서 사용됌
* 여러개의 값을 할당하여 그룹화 할때 사용
    * x, y =(10, 20)  이럴 때 사용
    * => 개발자가 쓰일이 없기 때문에 크게 의식하지 않아도 됌

### range = 연속된 정수 시퀀스를 생성하는 불변 자료형
* range(n) 
    * 0부터 n-1까지의 숫자 시퀀스
* range(n,m)
     * n 부터 m-1까지의 숫자 시퀀스
* 마지막에 -1 은 시작지점이 0이라는 인덱스의 특성을 고려한것이다 !
* range(n,m,s)
     * n 부터 m-1까지 s마다 건너뛴 숫자 시퀸스
     *  range[start:end:step]
     * start < end = start부터 end-1까지 step만큼 증가
     * start > end = start부터 end+1까지 step만큼 감소
  
*  ![사진8](<사진8 range 사용법.png>)
    * 리스트를 활용하여 값을 활용함

## Non-Sequence Types

### dict = 딕셔너리 (순서와 중복이 없는 가변 자료형) 
* Key : value 의 세트 형태
    * key는 불변형 자료형만 사용가능(str, int, float, tuple, range ...)
    * value는 모든 자료형 사용가능
* 중괄호 ( {} )로 표기
* ![사진9](<사진9 딕셔너리.png>)
    * Key를 활용하여 value에 접근 // 대괄호 ( [] )를 활용하여 값을 추출
    * 가변형이기에 키를 활용해 value값 변경 가능
```python
# dict안에 dict 또있는경우
my_dict = {
    'a1' : {'b1':1, 'b2':2, 'b3':3},
    'a2' : {'b1':4, 'b2':5, 'b3':6},
    'a3' : {'b1':7, 'b2':8, 'b3':9}
}
# value 5를 출력
print(my_dict['a2']['b2'])
# 다른방법 .get( ) 을 사용한다
print(my_dict.get('a2').get('b2'))

```
### set = 세트 ( 순서와 중복이 없는 가변 자료형)
* 수학에서의 집합이라 보면 됌
* 중괄호 ( {} )로 표기
* 빈 자료형은 꼭 "set( )" 로 표기 해야함 ( 딕셔너리와 겹치기 때문 )
* ![사진10](<사진10 세트 연산.png>)
    * 수학의 집합과 똑같은 연산
    * | 합집합 // - 차집합 // & 교집합 // 
    * 튜플과 같이 조금 독특하다
```python
# set 실습
set_1 = { 1,2,3,4,5,6,7,8,8,9,10}
set_2 = {2,3,5,6,8,9,11}
# 합집합
print(set_1 | set_2)
# 차집합
print(set_1 - set_2)
# 교집합
print(set_1 & set_2)
```
```python
# 세트의 사용예시 - 로또번호 추첨
import random

lotto_set=set()

while len(lotto_set) < 6 :
    number = random.randint(1,45)
    lotto_set.add(number) #set에 추가하는 .add

lotto_list = list(lotto_set)
lotto_list.sort  # sort는 오름차순 정렬
print(lotto_list)
```

## Other Types
### None = 값이 없을 표현하는 자료형
* 0이랑은 다르게 정말 값이 없다 라는 것을 표현

### boolean = 참과 거짓을 표현하는 자료형
* True 와 False
* 비교 / 논리 연산의 평과 결과로 사용
* 주로 조건/ 반복문과 함께 사용
* ![사진11](<사진11 불린.png>)

### collection = 여러개의 항목을 담는 자료구조
* str, list, tuple, set, dict
* ![사진12](<사진12 collection.png>)
    * 불변/가변과 순서 여부에 따라 나눠진다
    * range는 무의미하다용 
* 불변과 가변의 차이
    * 불변은 하나의 메모리 주소에 할당해서 바꿀수없다
    * 가변은 각각의 메모리 주소에 하나의 값을 할당하기 때문에 바꿀 수 있다.
    * 하여 **리스트를 객체의 참조를 모아놓은 컬렉션** 이라 칭함
```
List_1 = [1, 2, 3,]
List_2 = List_1

List_1[0] = 100
print(List_1) # [100, 2, 3]
print(List_2) # [100, 2, 3]
```
* 리스트는 같은 곳을 복사하여 변환시키지 않아도 똑같아짐 // 프레임은 다르나 객체를 공유하게 되기 때문이다.

---------------------------------------------------------------------------------------------------------
### 문자열 : ' ' 불변 시퀸스 자료형 -> 알고리즘 IM형 문자형 파싱(인덱싱, 슬라이싱 등)
### 리스트 : [ ] 가변 시퀸스 자료형 -> 알고리즘 IM형 방향배열 등 ,,, A형 DFS,BFS
### 튜플 : ( ) 불변 시퀸스 자료형 -> 알고리즘 방향배열 
### 레인지 : 생성형 불변 시퀀스 자료형
### 딕셔너리 : {key:value} 가변 비시퀸스 자료형-> ket : value -> DB의 Json 형식과 비슷
### 세트 : 가변 비시퀸스 자료형 -> 중복을 허용하지 않음 -> 집합
```
행- 가로 한줄을 뜻함
열- 세로 한줄을 뜻함

1행     1열 2열 3열 4열
2행
3행
4행
```

## Type Conversion = 형변환
### lmplicit Type Conversion = 암시적 형 변환
* 파이썬이 자동으로 형변환 하는 것
* Boolean과 Numeric Type에서만 가능 
정수 -> False = 0
실수 -> False = 0.0
문자열 -> False = "" (공백아니고 아예 없어야함)
* ![사진13](<사진13 암시적 형변환.png>)
* 때문에 더했을때 값이 나올 수 있게됌
* 정수 + 실수= 실수

### Explicit Type Conversion = 명시적 형변환
* 개발자가 직접 형변환 시키는 것
* str(문자열) -> integer : 형식에 맞는 숫자만 가능
* integer -> str : 모두 가능
```python
print(int('1')) #1
print(str(1)+'등' #1등
print(float( '3.5' )) # 3.5
print(int( 3.5 ) ) #3 // 형변환할때는 버림이 된다.
prunt(int( '3.5' ) ) # 에러발생
=> print( int( float('3.5') ) )  # 3
```
* ![사진14](<사진14 형변환.PNG>)

## 연산자
### 산술 연산자
* ![사진15](<사진15 산술연산자.PNG>)
### 복합연산자
* ![사진16](<사진16 복합연산잔.PNG>)
### 비교 연산자
* ![사진17](<사진17 비교연산자.PNG>)
* 항상 부등호가 먼저 사용되어야함
* ==, !=은 동등성을 띄고 값을 확인하나 is와 is not은 식별성을 띄고 레퍼런스(주소)를 비교한다.
* is 연산자는 되도록이면 None, True, False 등을 비교할 때 사용!
```python
print(2.0 == 2) # True
print(2,0 is 2) #False

a=3
b=3
print(a==b) #True
print(a is b) #False
```
### 논리연산자
* and(논리곱) = 모두 다 참이여야 True
* or(논리합) = 하나 만 참이여도 True
* not(논리부정) = True-> False // False->True
* 비교 연산자와 함께 사용가능하다

단축평가예시
* ![사진18](<사진18 단축평가.PNG>)
* and
    * 첫번째 피연산자가 False라면 전체표현식은 False이며 두번째 피연산자는 무시
    * 첫번째 피연산자가 True라면 두번째 피연산자에 의해 결정되며, 두번째 피연산자가 결과로 반환
* or
    * 첫번째 피연산자가 True라면 전체표현식은 True이며 두번째 피연산자는 무시
    * 첫번째 피연산자가 False라면 두번째 피연산자에 의해 결정되며, 두번째 피연산자가 결과로 반환
* a와b가 공백이 아니기때문에 true이며 두번째 연산자인 b가 포함되지않기에 false
* a와b가 공백이 아니기때문에 true이며 두번째 연산자인 a가 포함되기때문에 True
#### 단축평가는 코드실행을 최적화하여, 불필요한 연산을 줄이기 위해 시행.

### 멤버쉽 연산자 
* in = 왼쪽 피연산자가 오른쪽 피연산자의 시퀸스에 속하는지를 확인!
* not in = 왼쪽 피연산자가 오른쪽 피연산자의 시퀸스에 속하지않는지를 확인!
* ![사진19](<사진19 멤버쉽연산자.PNG>)

### 시퀸스형 연산자
* 시퀸스 간 연산에서 사용될 때 다른 역할을 가짐
* + 결합 연산자
* * 반복 연산자
* ![사진20](<사진20 시퀸스형연산자.PNG>)

### 연산자 우선순위
* ![사진21](<사진21 연산자 우선순위.PNG>)